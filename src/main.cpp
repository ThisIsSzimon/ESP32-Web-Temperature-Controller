#include <cstring>

extern "C" {
  #include "freertos/FreeRTOS.h"
  #include "freertos/task.h"
  #include "driver/i2c.h"
  #include "esp_log.h"
}

static const char* TAG = "SSD1306_TEST";

// I2C
constexpr int I2C_PORT = I2C_NUM_0;
constexpr gpio_num_t SDA_PIN = GPIO_NUM_21;
constexpr gpio_num_t SCL_PIN = GPIO_NUM_22;
constexpr uint32_t I2C_FREQ = 400000;
constexpr uint8_t  OLED_ADDR = 0x3C;   // spróbuj 0x3D jeśli nic nie ma

// Ekran
constexpr int OLED_W = 128;
constexpr int OLED_H = 64;

// ===== 5x7 ASCII 32..127, columns, LSB = top =====
static const uint8_t FONT5x7[96][5] = {
{0x00,0x00,0x00,0x00,0x00},{0x00,0x00,0x5F,0x00,0x00},{0x00,0x07,0x00,0x07,0x00},{0x14,0x7F,0x14,0x7F,0x14},
{0x24,0x2A,0x7F,0x2A,0x12},{0x23,0x13,0x08,0x64,0x62},{0x36,0x49,0x55,0x22,0x50},{0x00,0x05,0x03,0x00,0x00},
{0x00,0x1C,0x22,0x41,0x00},{0x00,0x41,0x22,0x1C,0x00},{0x14,0x08,0x3E,0x08,0x14},{0x08,0x08,0x3E,0x08,0x08},
{0x00,0x50,0x30,0x00,0x00},{0x08,0x08,0x08,0x08,0x08},{0x00,0x60,0x60,0x00,0x00},{0x20,0x10,0x08,0x04,0x02},
{0x3E,0x51,0x49,0x45,0x3E},{0x00,0x42,0x7F,0x40,0x00},{0x72,0x49,0x49,0x49,0x46},{0x21,0x41,0x49,0x4D,0x33},
{0x18,0x14,0x12,0x7F,0x10},{0x27,0x45,0x45,0x45,0x39},{0x3C,0x4A,0x49,0x49,0x31},{0x41,0x21,0x11,0x09,0x07},
{0x36,0x49,0x49,0x49,0x36},{0x46,0x49,0x49,0x29,0x1E},{0x00,0x36,0x36,0x00,0x00},{0x00,0x56,0x36,0x00,0x00},
{0x08,0x14,0x22,0x41,0x00},{0x14,0x14,0x14,0x14,0x14},{0x00,0x41,0x22,0x14,0x08},{0x02,0x01,0x59,0x09,0x06},
{0x3E,0x41,0x5D,0x59,0x4E},{0x7E,0x11,0x11,0x11,0x7E},{0x7F,0x49,0x49,0x49,0x36},{0x3E,0x41,0x41,0x41,0x22},
{0x7F,0x41,0x41,0x22,0x1C},{0x7F,0x49,0x49,0x49,0x41},{0x7F,0x09,0x09,0x09,0x01},{0x3E,0x41,0x49,0x49,0x7A},
{0x7F,0x08,0x08,0x08,0x7F},{0x00,0x41,0x7F,0x41,0x00},{0x20,0x40,0x41,0x3F,0x01},{0x7F,0x08,0x14,0x22,0x41},
{0x7F,0x40,0x40,0x40,0x40},{0x7F,0x02,0x0C,0x02,0x7F},{0x7F,0x04,0x08,0x10,0x7F},{0x3E,0x41,0x41,0x41,0x3E},
{0x7F,0x09,0x09,0x09,0x06},{0x3E,0x41,0x51,0x21,0x5E},{0x7F,0x09,0x19,0x29,0x46},{0x46,0x49,0x49,0x49,0x31},
{0x01,0x01,0x7F,0x01,0x01},{0x3F,0x40,0x40,0x40,0x3F},{0x1F,0x20,0x40,0x20,0x1F},{0x3F,0x40,0x38,0x40,0x3F},
{0x63,0x14,0x08,0x14,0x63},{0x07,0x08,0x70,0x08,0x07},{0x61,0x51,0x49,0x45,0x43},{0x00,0x7F,0x41,0x41,0x00},
{0x02,0x04,0x08,0x10,0x20},{0x00,0x41,0x41,0x7F,0x00},{0x04,0x02,0x01,0x02,0x04},{0x40,0x40,0x40,0x40,0x40},
{0x00,0x01,0x02,0x00,0x00},{0x20,0x54,0x54,0x54,0x78},{0x7F,0x48,0x44,0x44,0x38},{0x38,0x44,0x44,0x44,0x20},
{0x38,0x44,0x44,0x48,0x7F},{0x38,0x54,0x54,0x54,0x18},{0x08,0x7E,0x09,0x01,0x02},{0x0C,0x52,0x52,0x52,0x3E},
{0x7C,0x08,0x04,0x04,0x78},{0x00,0x44,0x7D,0x40,0x00},{0x7C,0x10,0x28,0x44,0x00},{0x7C,0x40,0x40,0x40,0x00},
{0x7C,0x08,0x10,0x08,0x7C},{0x7C,0x08,0x04,0x04,0x78},{0x38,0x44,0x44,0x44,0x38},{0x7C,0x14,0x14,0x14,0x08},
{0x08,0x14,0x14,0x18,0x7C},{0x7C,0x08,0x04,0x04,0x08},{0x48,0x54,0x54,0x54,0x20},{0x04,0x3F,0x44,0x40,0x20},
{0x3C,0x40,0x40,0x20,0x7C},{0x1C,0x20,0x40,0x20,0x1C},{0x3C,0x40,0x30,0x40,0x3C},{0x44,0x28,0x10,0x28,0x44},
{0x0C,0x50,0x50,0x50,0x3C},{0x44,0x64,0x54,0x4C,0x44},{0x00,0x08,0x36,0x41,0x00},{0x00,0x00,0x7F,0x00,0x00},
{0x00,0x41,0x36,0x08,0x00},{0x10,0x08,0x08,0x10,0x08}
};

static void i2c_init() {
  i2c_config_t c{};
  c.mode = I2C_MODE_MASTER;
  c.sda_io_num = SDA_PIN;
  c.scl_io_num = SCL_PIN;
  c.sda_pullup_en = GPIO_PULLUP_ENABLE;
  c.scl_pullup_en = GPIO_PULLUP_ENABLE;
  c.master.clk_speed = I2C_FREQ;
  ESP_ERROR_CHECK(i2c_param_config((i2c_port_t)I2C_PORT, &c));
  ESP_ERROR_CHECK(i2c_driver_install((i2c_port_t)I2C_PORT, I2C_MODE_MASTER, 0, 0, 0));
}

static esp_err_t oled_cmd(uint8_t cmd) {
  i2c_cmd_handle_t h = i2c_cmd_link_create();
  i2c_master_start(h);
  i2c_master_write_byte(h, (OLED_ADDR << 1) | I2C_MASTER_WRITE, true);
  i2c_master_write_byte(h, 0x00, true);   // command
  i2c_master_write_byte(h, cmd, true);
  i2c_master_stop(h);
  esp_err_t r = i2c_master_cmd_begin((i2c_port_t)I2C_PORT, h, pdMS_TO_TICKS(100));
  i2c_cmd_link_delete(h);
  return r;
}

static esp_err_t oled_data(const uint8_t* d, size_t n) {
  i2c_cmd_handle_t h = i2c_cmd_link_create();
  i2c_master_start(h);
  i2c_master_write_byte(h, (OLED_ADDR << 1) | I2C_MASTER_WRITE, true);
  i2c_master_write_byte(h, 0x40, true);   // data
  i2c_master_write(h, (uint8_t*)d, n, true);
  i2c_master_stop(h);
  esp_err_t r = i2c_master_cmd_begin((i2c_port_t)I2C_PORT, h, pdMS_TO_TICKS(200));
  i2c_cmd_link_delete(h);
  return r;
}

static void ssd1306_init_128x64() {
  oled_cmd(0xAE);            // display off
  oled_cmd(0xD5); oled_cmd(0x80); // clk
  oled_cmd(0xA8); oled_cmd(0x3F); // multiplex 1/64
  oled_cmd(0xD3); oled_cmd(0x00); // offset
  oled_cmd(0x40);            // start line = 0
  oled_cmd(0x8D); oled_cmd(0x14); // charge pump on
  oled_cmd(0x20); oled_cmd(0x00); // memory mode: horizontal
  oled_cmd(0xA1);            // seg remap
  oled_cmd(0xC8);            // COM scan dec
  oled_cmd(0xDA); oled_cmd(0x12); // COM pins
  oled_cmd(0x81); oled_cmd(0xCF); // contrast
  oled_cmd(0xD9); oled_cmd(0xF1); // precharge
  oled_cmd(0xDB); oled_cmd(0x40); // VCOM
  oled_cmd(0xA4);            // resume
  oled_cmd(0xA6);            // normal display
  oled_cmd(0x2E);            // deactivate scroll
  oled_cmd(0xAF);            // display on
}

static void oled_set_window(uint8_t x0, uint8_t x1, uint8_t page0, uint8_t page1) {
  oled_cmd(0x21); oled_cmd(x0); oled_cmd(x1);   // column addr
  oled_cmd(0x22); oled_cmd(page0); oled_cmd(page1); // page addr
}

static void oled_clear() {
  oled_set_window(0, OLED_W-1, 0, (OLED_H/8)-1);
  uint8_t z[16]; memset(z, 0x00, sizeof z);
  for (int i=0; i< (OLED_W*OLED_H/8)/16; ++i) oled_data(z, sizeof z);
}

static void draw_char(char c) {
  if (c < 32 || c > 127) c = '?';
  uint8_t buf[6];
  memcpy(buf, FONT5x7[c-32], 5);
  buf[5] = 0x00; // odstęp
  oled_data(buf, sizeof buf);
}

static void draw_text(uint8_t col, uint8_t page, const char* s) {
  oled_set_window(col, OLED_W-1, page, page);
  while (*s) draw_char(*s++);
}

extern "C" void app_main(void) {
  ESP_LOGI(TAG, "Init I2C + SSD1306");
  i2c_init();
  ssd1306_init_128x64();
  oled_clear();

  draw_text(0, 0, "HELLO");
  draw_text(0, 2, "SSD1306");
  draw_text(0, 4, "ESP32");

  while (true) vTaskDelay(pdMS_TO_TICKS(1000));
}
